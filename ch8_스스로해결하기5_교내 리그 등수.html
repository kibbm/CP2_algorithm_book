<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>팀 순위 시뮬레이터</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .container {
            max-width: 900px;
            margin: auto;
            padding: 2rem;
        }
        .node {
            width: 50px;
            height: 50px;
            border-radius: 9999px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 600;
            transition: all 0.3s ease-in-out;
            cursor: pointer;
        }
        .node-default {
            background-color: #e5e7eb;
            color: #4b5563;
            border: 2px solid #d1d5db;
        }
        .node-start {
            background-color: #f59e0b;
            color: #ffffff;
            border: 2px solid #d97706;
            transform: scale(1.2);
            box-shadow: 0 4px 6px rgba(245, 158, 11, 0.4);
        }
        .node-up {
            background-color: #ef4444;
            color: #ffffff;
            border: 2px solid #dc2626;
        }
        .node-down {
            background-color: #10b981;
            color: #ffffff;
            border: 2px solid #059669;
        }
        .node-other {
            background-color: #6b7280;
            color: #ffffff;
            border: 2px solid #4b5563;
        }
        .edge {
            stroke: #4b5563;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
            transition: stroke 0.3s ease-in-out;
        }
        .edge-up {
            stroke: #ef4444;
            stroke-width: 3;
            marker-end: url(#arrowhead-up);
        }
        .edge-down {
            stroke: #10b981;
            stroke-width: 3;
            marker-end: url(#arrowhead-down);
        }
        #result-text {
            white-space: pre-wrap;
        }
        .step-info {
            background-color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            min-height: 120px;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

<div class="container bg-white rounded-xl shadow-lg p-8">
    <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">팀 순위 시뮬레이터</h1>
    <p class="text-center text-gray-600 mb-8">
        특정 팀(X)의 순위 또는 순위 범위를 계산하는 시뮬레이션입니다.
    </p>

    <div class="grid md:grid-cols-2 gap-8 mb-8">
        <div>
            <div class="mb-4">
                <label for="N-input" class="block text-gray-700 font-medium mb-2">N (팀 개수)</label>
                <input type="number" id="N-input" value="6" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-4">
                <label for="edges-input" class="block text-gray-700 font-medium mb-2">
                    간선 (edges)
                    <span class="text-sm text-gray-500 block">형식: (1,3), (2,3), (3,4), (4,5), (3,6)</span>
                </label>
                <input type="text" id="edges-input" value="(1,3),(2,3),(3,4),(4,5),(3,6)" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-4">
                <label for="X-input" class="block text-gray-700 font-medium mb-2">X (기준 팀)</label>
                <input type="number" id="X-input" value="3" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="flex space-x-4 mb-6">
                <button onclick="runSimulation()" class="flex-1 bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 ease-in-out shadow-md">시뮬레이션 시작</button>
                <button onclick="resetSimulation()" class="bg-gray-400 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition duration-300 ease-in-out shadow-md">초기화</button>
            </div>
        </div>

        <div>
            <div class="step-info">
                <h3 class="text-xl font-semibold text-gray-800 mb-2">단계 정보</h3>
                <p id="step-description" class="text-gray-700"></p>
            </div>
            <div class="mt-4 flex space-x-2">
                <button id="prev-step-btn" onclick="prevStep()" class="flex-1 bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg hover:bg-gray-400 transition duration-300 ease-in-out shadow-md" disabled>이전 단계</button>
                <button id="next-step-btn" onclick="nextStep()" class="flex-1 bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition duration-300 ease-in-out shadow-md" disabled>다음 단계</button>
            </div>
            <div class="mt-4">
                <h3 class="text-xl font-semibold text-gray-800 mb-2">최종 결과</h3>
                <p id="result-text" class="text-gray-700 font-mono bg-gray-50 p-4 rounded-lg border border-gray-200"></p>
            </div>
        </div>
    </div>

    <!-- Graph Visualization -->
    <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 shadow-inner">
        <h2 class="text-2xl font-semibold text-center text-gray-800 mb-4">그래프 시각화</h2>
        <svg id="graph-svg" class="w-full h-[400px] bg-white rounded-lg border border-gray-200"></svg>
    </div>
</div>

<script>
    const NInput = document.getElementById('N-input');
    const edgesInput = document.getElementById('edges-input');
    const XInput = document.getElementById('X-input');
    const stepDescription = document.getElementById('step-description');
    const resultText = document.getElementById('result-text');
    const prevStepBtn = document.getElementById('prev-step-btn');
    const nextStepBtn = document.getElementById('next-step-btn');
    const svg = document.getElementById('graph-svg');

    let N, edges, X;
    let G, RG;
    let steps;
    let currentStep;

    let nodePositions = {};
    let nodeElements = {};
    let edgeElements = {};

    function parseEdges(edgesStr) {
        if (!edgesStr) return [];
        const regex = /\((\d+),(\d+)\)/g;
        const result = [];
        let match;
        while ((match = regex.exec(edgesStr)) !== null) {
            result.push([parseInt(match[1]), parseInt(match[2])]);
        }
        return result;
    }

    function initializeGraph() {
        N = parseInt(NInput.value);
        edges = parseEdges(edgesInput.value);
        X = parseInt(XInput.value);

        G = Array.from({ length: N + 1 }, () => []);
        RG = Array.from({ length: N + 1 }, () => []);

        edges.forEach(([u, v]) => {
            if (u > 0 && u <= N && v > 0 && v <= N) {
                G[u].push(v);
                RG[v].push(u);
            }
        });
    }

    function createGraphElements() {
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#4b5563" />
                </marker>
                <marker id="arrowhead-up" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#ef4444" />
                </marker>
                <marker id="arrowhead-down" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#10b981" />
                </marker>
            </defs>
        `;

        const width = svg.clientWidth;
        const height = svg.clientHeight;
        const center = { x: width / 2, y: height / 2 };
        const radius = Math.min(width, height) / 2.5;

        nodePositions = {};
        nodeElements = {};
        edgeElements = {};

        // 노드 위치 계산
        for (let i = 1; i <= N; i++) {
            const angle = (2 * Math.PI / N) * (i - 1);
            nodePositions[i] = {
                x: center.x + radius * Math.cos(angle),
                y: center.y + radius * Math.sin(angle)
            };
        }

        // 간선 그리기
        edges.forEach(([u, v]) => {
            const edgePath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const start = nodePositions[u];
            const end = nodePositions[v];
            
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const unitVx = dx / dist;
            const unitVy = dy / dist;

            const offset = 25; // 노드 반지름
            const newStart = { x: start.x + unitVx * offset, y: start.y + unitVy * offset };
            const newEnd = { x: end.x - unitVx * offset, y: end.y - unitVy * offset };

            let pathData = `M ${newStart.x} ${newStart.y} L ${newEnd.x} ${newEnd.y}`;

            edgePath.setAttribute('d', pathData);
            edgePath.setAttribute('class', 'edge');
            edgePath.setAttribute('id', `edge-${u}-${v}`);
            svg.appendChild(edgePath);
            edgeElements[`${u}-${v}`] = edgePath;
        });

        // 노드 그리기
        for (let i = 1; i <= N; i++) {
            const nodeG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const pos = nodePositions[i];
            if (pos) {
                nodeG.setAttribute('transform', `translate(${pos.x}, ${pos.y})`);
                nodeG.setAttribute('class', 'node node-default');

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', 25);
                circle.setAttribute('fill', '#e5e7eb');
                circle.setAttribute('stroke', '#d1d5db');
                circle.setAttribute('stroke-width', '2');
                nodeG.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('alignment-baseline', 'middle');
                text.setAttribute('font-size', '1.5rem');
                text.setAttribute('font-weight', '600');
                text.setAttribute('fill', '#4b5563');
                text.textContent = i;
                nodeG.appendChild(text);

                svg.appendChild(nodeG);
                nodeElements[i] = nodeG;
            }
        }
    }

    function runSimulation() {
        try {
            resetSimulation();
            initializeGraph();
            createGraphElements();
            
            // X 노드 강조
            if (nodeElements[X]) {
                nodeElements[X].setAttribute('class', 'node node-start');
                nodeElements[X].querySelector('circle').style.fill = '#f59e0b';
                nodeElements[X].querySelector('circle').style.stroke = '#d97706';
                nodeElements[X].querySelector('text').style.fill = '#ffffff';
            }


            steps = [];

            // 1단계: 초기 상태
            steps.push({
                type: 'initial',
                description: `기준 팀 ${X}를 선택하고 시뮬레이션을 준비합니다.`,
                visitedUp: [],
                visitedDown: [],
                X: X
            });

            // 2단계: 위로 탐색 (X보다 앞서는 팀 찾기)
            let qUp = [X];
            let seenUp = new Set([X]);
            let countUp = 0;
            let tempStepsUp = [];

            while(qUp.length > 0) {
                let v = qUp.shift();
                RG[v].forEach(nv => {
                    if (!seenUp.has(nv)) {
                        seenUp.add(nv);
                        countUp++;
                        qUp.push(nv);
                        tempStepsUp.push({
                            v: v,
                            nv: nv
                        });
                    }
                });
            }

            steps.push({
                type: 'search-up-start',
                description: `팀 ${X}보다 순위가 높은 팀들을 찾기 위해 역방향으로 탐색을 시작합니다.`,
                X: X,
                visitedUp: [...seenUp]
            });

            tempStepsUp.forEach(step => {
                steps.push({
                    type: 'search-up',
                    description: `팀 ${step.v}에서 역방향으로 팀 ${step.nv}를 탐색합니다.`,
                    v: step.v,
                    nv: step.nv,
                    visitedUp: [...seenUp]
                });
            });

            // 3단계: 아래로 탐색 (X보다 뒤에 오는 팀 찾기)
            let qDown = [X];
            let seenDown = new Set([X]);
            let countDown = 0;
            let tempStepsDown = [];

            while(qDown.length > 0) {
                let v = qDown.shift();
                G[v].forEach(nv => {
                    if (!seenDown.has(nv)) {
                        seenDown.add(nv);
                        countDown++;
                        qDown.push(nv);
                        tempStepsDown.push({
                            v: v,
                            nv: nv
                        });
                    }
                });
            }

            steps.push({
                type: 'search-down-start',
                description: `팀 ${X}보다 순위가 낮은 팀들을 찾기 위해 순방향으로 탐색을 시작합니다.`,
                X: X,
                visitedUp: [...seenUp]
            });
            
            tempStepsDown.forEach(step => {
                steps.push({
                    type: 'search-down',
                    description: `팀 ${step.v}에서 순방향으로 팀 ${step.nv}를 탐색합니다.`,
                    v: step.v,
                    nv: step.nv,
                    visitedUp: [...seenUp],
                    visitedDown: [...seenDown]
                });
            });

            // 4단계: 최종 결과 계산
            if (countUp + countDown === N - 1) {
                steps.push({
                    type: 'final-rank',
                    description: `총 ${countUp + countDown}개의 팀이 팀 ${X}와 연결되어 있습니다. 모든 팀이 연결되어 있으므로, 순위가 유일하게 결정됩니다.`,
                    up: countUp,
                    down: countDown,
                    finalResult: `rank= ${1 + countUp}`
                });
            } else {
                steps.push({
                    type: 'final-range',
                    description: `팀 ${X}와 연결되지 않은 팀이 있어 순위가 유일하지 않습니다.`,
                    up: countUp,
                    down: countDown,
                    finalResult: `range= [${1 + countUp}, ${N - countDown}]`
                });
            }

            currentStep = -1;
            nextStep();
            prevStepBtn.disabled = true;
            nextStepBtn.disabled = false;
        } catch (e) {
            console.error("An error occurred during simulation:", e);
            stepDescription.textContent = `오류 발생: ${e.message}. 콘솔을 확인해주세요.`;
            resultText.textContent = `시뮬레이션 중 오류가 발생했습니다.`;
        }
    }

    function resetSimulation() {
        svg.innerHTML = '';
        stepDescription.textContent = '시뮬레이션을 시작하려면 버튼을 클릭하세요.';
        resultText.textContent = '아직 결과가 없습니다.';
        prevStepBtn.disabled = true;
        nextStepBtn.disabled = true;
        currentStep = -1;
        nodePositions = {};
        nodeElements = {};
        edgeElements = {};
    }
    
    function updateVisualization() {
        if (currentStep < 0 || currentStep >= steps.length) return;

        const step = steps[currentStep];

        // 노드 및 간선 초기화
        for (let i = 1; i <= N; i++) {
            if (nodeElements[i]) {
                nodeElements[i].setAttribute('class', 'node node-default');
                nodeElements[i].querySelector('circle').style.fill = '#e5e7eb';
                nodeElements[i].querySelector('circle').style.stroke = '#d1d5db';
                nodeElements[i].querySelector('text').style.fill = '#4b5563';
            }
        }
        for (const key in edgeElements) {
            if (edgeElements[key]) {
                 edgeElements[key].setAttribute('class', 'edge');
                 edgeElements[key].style.stroke = '#4b5563';
                 edgeElements[key].setAttribute('marker-end', 'url(#arrowhead)');
            }
        }
        
        stepDescription.textContent = step.description;

        // 노드 상태 업데이트
        nodeElements[X].setAttribute('class', 'node node-start');

        if (step.visitedUp) {
            step.visitedUp.forEach(node => {
                if (node !== X) {
                    nodeElements[node].setAttribute('class', 'node node-up');
                }
            });
        }
        if (step.visitedDown) {
            step.visitedDown.forEach(node => {
                if (node !== X) {
                    nodeElements[node].setAttribute('class', 'node node-down');
                }
            });
        }

        if (step.type === 'search-up') {
            const edge = edgeElements[`${step.nv}-${step.v}`];
            if (edge) {
                 edge.setAttribute('class', 'edge edge-up');
                 edge.style.stroke = '#ef4444';
                 edge.setAttribute('marker-end', 'url(#arrowhead-up)');
            }
        } else if (step.type === 'search-down') {
            const edge = edgeElements[`${step.v}-${step.nv}`];
            if (edge) {
                 edge.setAttribute('class', 'edge edge-down');
                 edge.style.stroke = '#10b981';
                 edge.setAttribute('marker-end', 'url(#arrowhead-down)');
            }
        } else if (step.type === 'final-rank' || step.type === 'final-range') {
            for (let i = 1; i <= N; i++) {
                const isUp = step.visitedUp ? step.visitedUp.includes(i) : false;
                const isDown = step.visitedDown ? step.visitedDown.includes(i) : false;
                
                if (i === X) {
                    nodeElements[i].setAttribute('class', 'node node-start');
                } else if (isUp) {
                    nodeElements[i].setAttribute('class', 'node node-up');
                } else if (isDown) {
                    nodeElements[i].setAttribute('class', 'node node-down');
                } else {
                    nodeElements[i].setAttribute('class', 'node node-other');
                }
            }
            resultText.textContent = step.finalResult;
        }
    }

    function nextStep() {
        if (currentStep < steps.length - 1) {
            currentStep++;
            updateVisualization();
            prevStepBtn.disabled = false;
        }
        if (currentStep === steps.length - 1) {
            nextStepBtn.disabled = true;
        }
    }

    function prevStep() {
        if (currentStep > 0) {
            currentStep--;
            updateVisualization();
            nextStepBtn.disabled = false;
        }
        if (currentStep === 0) {
            prevStepBtn.disabled = true;
        }
    }

    window.onload = resetSimulation;

</script>

</body>
</html>
